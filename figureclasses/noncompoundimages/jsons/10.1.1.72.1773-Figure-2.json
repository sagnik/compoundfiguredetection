{"Caption":"Figure 2: The Design of In-Page Logging","ImageText":[],"Mention":["As is mentioned in the design manifesto (Section 2.3), the main\ndesign changes we propose to make to the overall DBMS archi-\ntecture are limited to the buffer manager and storage manager. In\norder to realize the basic concepts of the in-page logging with the\nminimal cost, logging needs to be done by the buffer manager as\nwell as the storage manager. See Figure 2 for the illustration of the\nIPL design.\n","at once and consequently frequent erase operations can be avoided.\nWhen a dirty page is evicted, it is not necessary to write the content\nof the dirty page back to flash memory, because all of its updates\nare saved in the form of log records in flash memory. Thus, the\nprevious version of the data page remains intact in flash memory,\nbut is just augmented with the update log records.\nWhen an in-memory log sector is to be flushed to flash memory,\nits content is written to a flash log sector in the erase unit which\nits corresponding data page belongs to, so that the data page and\nits log records are physically co-located in the same erase unit. To\ndo this, the IPL storage manager divides each erase unit of flash\nmemory into two segments \u2013 one for data pages and the other for\nlog sectors. For example, as shown in Figure 2, an erase unit of\n128 KBytes (commonly known as large block NAND flash) can be\ndivided into 15 data pages of 8 KBytes each and 16 log sectors of\n512 bytes each. (Obviously, the size of an in-memory log sector\nmust be the same as that of a flash log sector.) When an erase unit\nruns out of free log sectors, the IPL storage manager merges the\ndata pages and log sectors in the erase unit into a new erase unit.\nThis new merge operation proposed as an internal function of IPL\nwill be presented in Section 3.3 in more detail.\nThis new logic for update requires the redefinition of read oper-\nation as well. When a data page is to be read from flash memory\ndue to a page fault, the current version of the page has to be com-\nputed on the fly by applying its log records to the previous version\nof the data page fetched from flash memory. This new logic for\nread operation clearly incurs additional overhead for both IO cost\n(to fetch a log sector from flash memory) and computational cost\n(to compute the current version of a data page). As is pointed out\nin Section 3.1, however, this in-page logging approach will even-\ntually improve the overall performance of the buffer and storage\nmanagers considerably, because write and erase operations will be\nrequested less frequently.\nThe memory overhead is another factor to be examined for the\ndesign of IPL. In the worst case in which all the pages in the buffer\npool are dirty, an in-memory log sector has to be allocated for each\nbuffer page. In the real-world applications, however, an update to\na base item is likely to be quickly followed by updates to the same\nor related items (known as update locality) [1], and the average\nratio of dirty pages in buffer is about 5 to 20 percent [14]. With\nsuch a low ratio of dirty pages, if a data page is 8 KBytes and\nan in-memory log sector is 512 bytes, then the additional memory\nrequirement will be no more than 1.3% of the size of the buffer\npool. Refer to Section 4.2.2 for the update pattern of the TPC-C\nbenchmark.\n"],"Page":4,"Number":2,"Type":"Figure","CaptionBB":[496,782,715,795],"Height":1100,"Width":850,"DPI":100,"ImageBB":[474,579,739,767]}