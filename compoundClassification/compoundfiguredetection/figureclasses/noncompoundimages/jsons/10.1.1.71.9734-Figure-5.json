{"Caption":"Figure 5: An example of why conditioning on a sin- gle element is enough. Here, T3M and T5M are in- dependent measures given T2M = 1. If T2M is 1, by assumption we know that T2 = 1, because measure- ment error is one-sided. T0 is 1 by backward deter- minism, which means that we are effectively asking if T3M and T5M are independent given T0 = 1, which is entailed by the graphical structure. ","ImageText":[{"Text":"T","TextBB":[541.355,82.2655,552.445,98.6],"Rotation":0},{"Text":"5","TextBB":[552.699,92.2442,557.236,100.411],"Rotation":0},{"Text":"T","TextBB":[594.291,82.2656,605.381,98.6001],"Rotation":0},{"Text":"5","TextBB":[605.634,92.2441,610.172,100.411],"Rotation":0},{"Text":"5M","TextBB":[605.635,92.2442,618.239,100.411],"Rotation":0},{"Text":"T","TextBB":[594.291,112.514,605.381,128.849],"Rotation":0},{"Text":"1","TextBB":[605.634,122.493,610.172,130.661],"Rotation":0},{"Text":"T","TextBB":[499.763,116.295,510.852,132.63],"Rotation":0},{"Text":"4","TextBB":[511.106,126.275,515.643,134.442],"Rotation":0},{"Text":"T","TextBB":[541.355,138.982,552.445,155.317],"Rotation":0},{"Text":"0","TextBB":[552.699,148.961,557.236,157.129],"Rotation":0},{"Text":"T","TextBB":[647.228,138.982,658.317,155.317],"Rotation":0},{"Text":"3","TextBB":[658.571,148.961,663.109,157.129],"Rotation":0},{"Text":"T","TextBB":[594.291,165.45,605.381,181.785],"Rotation":0},{"Text":"2","TextBB":[605.635,175.429,610.172,183.597],"Rotation":0},{"Text":"T","TextBB":[696.382,138.982,707.471,155.317],"Rotation":0},{"Text":"3M","TextBB":[707.725,148.961,720.33,157.129],"Rotation":0},{"Text":"T","TextBB":[662.353,169.232,673.442,185.567],"Rotation":0},{"Text":"2M","TextBB":[673.696,179.211,686.3,187.379],"Rotation":0}],"Mention":["It is necessary because by our assumptions there might be\nmeasurement error when we observe value 0. It is sufficient\nbecause by backward determinism (if a task happens, all ele-\nments in a chain before it also happened), we do not need to\ncondition on multiple tasks. Figure 5 illustrates an example\nof this case.\n","{1, 2, 3, 4, 5}. When inserting hidden joins for elements in\nAncestralSet, we will perform an operation analogous to\nour previous example of HiddenSplits, but with arrows di-\nrected in the opposite way. The modification in shown in\nFigure 15(a), while Figure 15(b) depicts the modification\nof the relation between {6, 7, 12}. The last step of our\nInsertLatents iteration simply connects the childless node\nof Figure 15(a) to the parentless node of Figure 15(b).\n"],"Page":5,"Number":5,"Type":"Figure","CaptionBB":[438,220,772,336],"Height":1169,"Width":826,"DPI":100,"ImageBB":[486,73,726,192]}