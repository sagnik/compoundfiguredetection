{"Caption":"Figure 3: Snapshots of the Nile-PDT visualization tools: (a) client visualization (b) server visualization","ImageText":[{"Text":"(a)","TextBB":[231.167,396.383,246.65,408.836],"Rotation":0},{"Text":"(b)","TextBB":[607.65,396.383,623.964,408.836],"Rotation":0}],"Mention":["A graphical user interface (GUI) is developed for both the\nNile-PDT client and the Nile server to visualize the phe-\nnomenon detection and tracking processes. Figure 3 gives\nsnapshots of the GUI of both the client and the server. Our\ndemo has two setups: one where the sensor network is sim-\nulated (as described in Section 4) and the other is using\nreal sensors, as described below. Our demo hardware con-\nsists of a grid of heat sensors that are connected via a wire-\nless sensor platform [4]. Each platform is represented as an\n","OSGi service bundle [6] in the sensor network. The sensor\nplatform used in Nile-PDT has a flexible modular architec-\nture that consists of a processing module, a communication\nmodule, and a testing module (Figure 4). Each sensor plat-\nform has a limited processing capability. Details about the\nsensor platform and the modules can be found in [4].\nWhen we run the demo using a simulated sensor net-\nwork, the client GUI (Figure 3a) represents each sensor\nby a circle that reflects its location in space. Sensors are\nspread all over the space arbitrarily. The client can keep\ntrack of both the original phenomena that are computed of-\nfline given infinite resources (depicted as gray circles) and\nthe phenomena that are detected by the system (depicted as\nblack circles). The client GUI shows the efficiency of the\nsystem in two aspects: (1) the number of detected phenom-\nena relative to the original number of existing phenomena,\nand (2) the response time (delay) of the system. The re-\nsponse time is identified by how far the detected phenom-\nena propagation lags after the original phenomena propa-\ngation.\nThe server GUI (Figure 3b) demonstrates the system\u2019s\ninternals and shows how the query plan is executed. The\nquery plan is displayed graphically and the incoming tu-\nples keep moving up the query plan from one operator to\nthe next. When we run the demo using a simulated sensor\nnetwork, the server can be executed in slow-motion (via in-\nserted delays) and the number of sensors is reduced for the\nsake of demo clarity.\n"],"Page":4,"Number":3,"Type":"Figure","CaptionBB":[140,424,713,438],"Height":1100,"Width":850,"DPI":100,"ImageBB":[89,75,765,410]}