{"Caption":"Figure 9: The 2 columns correspond to the first 2 iterations of the runtime path finding phase for this example. The top row shows the start (green sphere) in each iteration, and the sub-goal (red sphere) selected from the coarse-level path. The bottom row shows the path returned by the path finding algorithm (light and dark blue) and the partial path chosen (dark blue only). An estimate of the outline of the precom- puted tree is shown. The tree is transformed to the global space only in the figure to show how it relates to the other parts of the environment. There is only one precomputed tree, and it is never transformed to the global space in the algorithm. ","ImageText":[],"Mention":["Sub-goal Selection The coarse level path has many points\nthat we can use as sub-goals. Intuitively, we would like to\nfind ones that will be within the dark red regions (Figure 4)\nof the precomputed tree. We choose the sub-goal to be the\npoint in the coarse path that is closest to a fixed distance\naway from the start (Figure 9). A distance between 10 and\n12 meters worked well in our examples. Note that the start\nis different for each iteration of the path finding phase.\n","More specifically, if the current sub-goal is not annotated\nas being near a special obstacle or the final goal, we keep\nthe whole solution path. Otherwise, we only keep the first 2\nmotion states of the solution path (Figure 9 bottom). In addi-\ntion, if the solution path includes a special motion state, we\ntake all the states up to and including it. This is an optional\nadjustment that again helps the character in adjusting itself\nbefore executing a special motion. Our experiments show\nthat without this adjustment, the algorithm may sometimes\ninaccurately report that there is no solution.\n","The solution path from the algorithm is in the coordinate\nsystem of the precomputed tree. We must therefore trans-\nform (Tâˆ’1) each node in the path back to the global coordi-\nnate system. The bottom row of Figure 9 shows examples of\nthe algorithm\u2019s output. Before running a new iteration of the\npath finding phase, we reset the tree by UNBLOCK-ing the\nnodes that were previously BLOCKED.\n"],"Page":6,"Number":9,"Type":"Figure","CaptionBB":[98,291,399,471],"Height":1100,"Width":850,"DPI":100,"ImageBB":[98,111,401,281]}