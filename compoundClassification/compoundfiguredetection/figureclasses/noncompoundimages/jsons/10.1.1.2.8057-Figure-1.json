{"Caption":"Figure 1: The Linux virtual memory layout on 32-bit architectures. ","ImageText":[{"Text":"4GB","TextBB":[517.12,102.662,549.988,117.014],"Rotation":0},{"Text":"3GB","TextBB":[517.12,141.791,549.988,156.143],"Rotation":0},{"Text":"Kernel","TextBB":[578.943,128.748,644.678,143.1],"Rotation":0},{"Text":"User","TextBB":[589.899,160.087,633.722,174.439],"Rotation":0},{"Text":"Unmapped","TextBB":[568.151,202.088,655.797,216.44],"Rotation":0},{"Text":"0","TextBB":[541.118,259.175,552.074,273.527],"Rotation":0},{"Text":"User","TextBB":[589.899,246.132,633.722,260.484],"Rotation":0}],"Mention":["All Unix and Windows operating systems are suscepti-\nble to user pointer bugs, but we\u2019ll explain them in the\ncontext of Linux. On 32-bit computers, Linux divides\nthe virtual address space seen by user processes into two\nsections, as illustrated in Figure 1. The virtual memory\nspace from 0 to 3GB is available to the user process. The\nkernel executable code and data structures are mapped\ninto the upper 1GB of the process\u2019 address space. In\norder to protect the integrity and secrecy of the kernel\ncode and data, the user process is not permitted to read\nor write the top 1GB of its virtual memory. When a user\nprocess makes a system call, the kernel doesn\u2019t need to\nchange VM mappings, it just needs to enable read and\nwrite access to the top 1GB of virtual memory. It dis-\nables access to the top 1GB before returning control to\nthe user process.\n"],"Page":2,"Number":1,"Type":"Figure","CaptionBB":[433,308,745,339],"Height":1100,"Width":850,"DPI":100,"ImageBB":[516,100,667,273]}