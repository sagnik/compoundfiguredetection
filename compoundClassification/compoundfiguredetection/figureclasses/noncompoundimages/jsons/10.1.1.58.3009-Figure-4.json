{"Caption":"Figure 4: Architectural design space for secure information pro- cessing ","ImageText":[{"Text":"Overall","TextBB":[501.297,670.204,529.794,678.133],"Rotation":0},{"Text":"architecture","TextBB":[531.965,670.204,578.032,678.133],"Rotation":0},{"Text":"EP","TextBB":[620.316,700.344,631.527,708.274],"Rotation":0},{"Text":"with","TextBB":[633.734,700.344,650.318,708.274],"Rotation":0},{"Text":"EP","TextBB":[555.086,706.834,566.385,714.763],"Rotation":0},{"Text":"with","TextBB":[568.482,706.834,585.175,714.763],"Rotation":0},{"Text":"ASIP","TextBB":[593.037,703.204,613.133,711.133],"Rotation":0},{"Text":"GPx","TextBB":[627.026,711.014,643.64,718.944],"Rotation":0},{"Text":"(EP","TextBB":[595.016,713.764,609.199,721.693],"Rotation":0},{"Text":"COP","TextBB":[560.805,717.394,579.499,725.323],"Rotation":0},{"Text":"with","TextBB":[584.896,724.324,601.541,732.253],"Rotation":0},{"Text":"SPx)","TextBB":[603.757,724.324,621.342,732.253],"Rotation":0},{"Text":"Architectural","TextBB":[533.307,736.534,584.26,744.463],"Rotation":0},{"Text":"parameters","TextBB":[586.431,736.534,629.582,744.463],"Rotation":0},{"Text":"ASICs","TextBB":[443.547,707.494,467.957,715.423],"Rotation":0},{"Text":"EP","TextBB":[474.677,708.265,485.888,716.194],"Rotation":0},{"Text":"with","TextBB":[488.095,708.265,504.68,716.194],"Rotation":0},{"Text":"EP","TextBB":[513.287,706.284,524.596,714.213],"Rotation":0},{"Text":"with","TextBB":[526.693,706.284,543.376,714.213],"Rotation":0},{"Text":"FPGA","TextBB":[477.757,716.735,501.609,724.664],"Rotation":0},{"Text":"HWaccel","TextBB":[511.197,714.754,545.436,722.684],"Rotation":0},{"Text":"wordsize","TextBB":[444.427,770.194,477.707,778.123],"Rotation":0},{"Text":"#","TextBB":[484.797,770.524,489.202,778.453],"Rotation":0},{"Text":"registers","TextBB":[491.507,770.524,523.753,778.453],"Rotation":0},{"Text":"#pipeline","TextBB":[525.167,769.534,559.465,777.463],"Rotation":0},{"Text":"#instructions","TextBB":[558.055,767.664,607.122,775.593],"Rotation":0},{"Text":"stages","TextBB":[530.996,780.094,553.559,788.023],"Rotation":0},{"Text":"per","TextBB":[565.756,778.224,578.465,786.153],"Rotation":0},{"Text":"cycle","TextBB":[580.715,778.224,599.369,786.153],"Rotation":0},{"Text":"Choice","TextBB":[494.697,817.494,520.619,825.423],"Rotation":0},{"Text":"of","TextBB":[522.757,817.494,530.095,825.423],"Rotation":0},{"Text":"custom","TextBB":[498.876,828.054,525.905,835.983],"Rotation":0},{"Text":"instructions","TextBB":[490.187,838.614,534.779,846.543],"Rotation":0},{"Text":"Embedded","TextBB":[461.697,929.222,492.588,941.113],"Rotation":0},{"Text":"general-purpose","TextBB":[461.697,937.142,509.302,949.033],"Rotation":0},{"Text":"cache","TextBB":[632.197,767.664,653.268,775.593],"Rotation":0},{"Text":"architecture","TextBB":[619.657,778.224,665.699,786.153],"Rotation":0},{"Text":"SPx:","TextBB":[524.397,925.513,539.346,931.792],"Rotation":0},{"Text":"special","TextBB":[524.397,929.222,544.077,941.113],"Rotation":0},{"Text":"purpose","TextBB":[546.058,929.222,569.472,941.113],"Rotation":0},{"Text":"extensions","TextBB":[524.397,937.142,555.398,949.033],"Rotation":0},{"Text":"GPx:","TextBB":[590.397,925.513,606.007,931.792],"Rotation":0},{"Text":"general","TextBB":[590.397,929.222,612.162,941.113],"Rotation":0},{"Text":"purpose","TextBB":[614.147,929.222,637.671,941.113],"Rotation":0},{"Text":"extensions","TextBB":[590.397,937.142,621.399,949.033],"Rotation":0},{"Text":"Base","TextBB":[716.897,744.646,739.012,761.347],"Rotation":0},{"Text":"processor","TextBB":[705.238,756.526,750.667,773.226],"Rotation":0},{"Text":"parameters","TextBB":[700.948,768.405,755.072,785.106],"Rotation":0},{"Text":"Security","TextBB":[705.787,806.687,746.158,823.388],"Rotation":0},{"Text":"Processing","TextBB":[701.607,818.567,750.337,835.267],"Rotation":0},{"Text":"features","TextBB":[705.458,830.446,746.488,847.147],"Rotation":0},{"Text":"Choice","TextBB":[602.607,819.914,628.532,827.843],"Rotation":0},{"Text":"of","TextBB":[630.67,819.914,638.008,827.843],"Rotation":0},{"Text":"HW","TextBB":[588.637,830.474,604.267,838.403],"Rotation":0},{"Text":"accelerators","TextBB":[606.457,830.474,652.127,838.403],"Rotation":0},{"Text":"Attack","TextBB":[709.307,870.817,741.76,887.518],"Rotation":0},{"Text":"resistant","TextBB":[704.137,882.697,746.82,899.397],"Rotation":0},{"Text":"features","TextBB":[705.017,894.576,746.048,911.277],"Rotation":0},{"Text":"Concurrent","TextBB":[554.757,872.934,598.741,880.863],"Rotation":0},{"Text":"fault","TextBB":[600.977,872.934,618.505,880.863],"Rotation":0},{"Text":"detection?","TextBB":[567.296,883.494,606.026,891.423],"Rotation":0},{"Text":"Secure","TextBB":[459.607,873.814,484.955,881.743],"Rotation":0},{"Text":"memory","TextBB":[487.203,873.814,518.572,881.743],"Rotation":0},{"Text":"space?","TextBB":[476.546,884.374,501.522,892.303],"Rotation":0},{"Text":"EP:","TextBB":[461.697,925.513,472.578,931.792],"Rotation":0},{"Text":"Secure","TextBB":[659.697,700.894,685.17,708.823],"Rotation":0},{"Text":"EP","TextBB":[666.846,711.564,678.059,719.493],"Rotation":0},{"Text":"Macro-","TextBB":[705.897,679.197,741.209,695.898],"Rotation":0},{"Text":"architecture","TextBB":[693.907,691.077,753.093,707.777],"Rotation":0},{"Text":"parameters","TextBB":[696.437,702.956,750.561,719.657],"Rotation":0},{"Text":"HWaccel","TextBB":[653.097,925.513,681.683,931.792],"Rotation":0},{"Text":"hardware","TextBB":[653.097,929.222,680.47,941.113],"Rotation":0},{"Text":"accelerators","TextBB":[653.097,937.142,688.057,949.033],"Rotation":0},{"Text":"COP:","TextBB":[712.497,925.513,728.656,931.792],"Rotation":0},{"Text":"co-processor","TextBB":[712.497,929.222,749.549,941.113],"Rotation":0}],"Mention":["In the past, embedded systems tended to perform one or a few fixed func-\ntions. The trend is for embedded systems to perform multiple functions and\nalso to provide the ability to download new software to implement new or\nupdated applications in the field, rather than only in the more controlled en-\nvironment of the factory. While this certainly increases the flexibility and\nuseful lifetime of an embedded system, it poses new challenges in terms\nof the increased likelihood of attacks by malicious parties. An embedded\nsystem should ideally provide required security functions, implement them\nefficiently and also defend against attacks by malicious parties. We dis-\ncuss these below, especially in the context of the additional challenges faced\nby resource-constrained embedded systems in an environment of ubiquitous\nnetworking and pervasive computing.\nFigure 4 illustrates the architectural design space for secure embedded\nprocessing systems. Different macro-architecture models are listed in the\nfirst row, and described further below. These include embedded general-\npurpose processor (EP) vs. application-specific instruction set processor\n(ASIP) vs. EP with custom hardware accelerators connected to the pro-\ncessor bus, etc.). The second row details instruction-set architecture and\nmicro-architecture choices for tuning the base processor where appropriate.\nThe third row articulates security processing features that must be chosen\nor designed. For example, choosing the functionality to be implemented\nby custom instructions, hardware accelerators or general-purpose instruc-\ntion primitives. The fourth row involves selection of attack-resistant fea-\ntures in the embedded processor and embedded system design. These protect\nagainst both software attacks and physical attacks, as illustrated in section 4.\nThis may include an enhanced memory management unit to manage a secure\nmemory space, process isolation architecture, additional redundant circuitry\nfor thwarting power analysis attacks, and fault detection circuitry.\n","in the design of block ciphers that is very slow in existing processors [44,\n45]. Such bit-level permutation operations can quickly achieve diffusion in\nblock ciphers, a technique identified by Shannon [46] as fundamental to the\ndesign of block ciphers. Several different bit permutation instructions were\nrecently proposed [44, 47, 48, 49] that allow any one of the n! permutations\nof the n bits in a register (or block to be enciphered) to be achieved in at most\nO(log(n)) instructions. This has been further reduced to O(1) cycles in both\ngeneral-purpose [50] and ASIP [45] architectures. This is much faster than\nthe O(n) instructions or cycles needed using existing instructions available\nin processors. The versatility of these bit permutation instruction primitives\nhas also been demonstrated, for example, in the radical acceleration of the\nsorting of lists of bytes [51].\nGeneral-purpose instruction primitives for asymmetric (public-key) ci-\nphers are very different from those used in symmetric ciphers. They tend\nto be focussed on accelerating a large number of modular multiplication\noperations on large operands, e.g., 1024 bit numbers, in order to imple-\nment the main underlying operation \u2013 modular exponentiation, in algorithms\nsuch as RSA, Diffie-Hellman and El Gamal. Newer public-key algorithms\nsuch as Elliptic Curve Cryptography (ECC) [52] focus on computationally\nfaster operations and smaller operands; ECC on binary fields perform poly-\nnomial multiplication rather than integer multiplication, using much shorter\noperands to achieve equivalent levels of security. For example, 163 bit ECC\nkeys are thought to provide security equivalent to 1024 bit RSA keys. On\nthe implementation side, the trend has been to implement dual-field multipli-\ners [53] that can efficiently perform both integer and binary multiplications\non the same multiplier circuit.\nRecently, new instruction-set architectures have been proposed for tiny\ngeneral-purpose processors with general-purpose extensions to accelerate\nboth symmetric ciphers and asymmetric ciphers. For example, PAX [54]\nis a minimalist RISC (Reduced Instruction Set Computer) processor with a\nfew additional (but simple to implement) instructions that accelerate both\nECC public key operations and block cipher operations, and can achieve the\nlink speeds of current and proposed wireless networks at low MHz rates.\nThis approach is quite promising for embedded processors in smart cards,\nsensors and hand-held devices, where flexibility is required with small form\nfactors and very low energy consumption.\nThe above macro architectural models often overlap and blend from one\nto another. The most effective and efficient custom instructions for ASIPs, or\nISA primitives for \u201CEP with GPx\u201D architectures, are by no means resolved.\nMore research is needed. Also, interaction between cryptography algorithm\ndesigners and processor designers is encouraged [55]. The last three rows of\nFigure 4 illustrate detailed architectural decisions that must be made to fully\ndefine the secure embedded processing architecture.\nSecurity processing also involves security protocol processing, although\na large portion of this is taken by the actual cryptography processing. New\nwork is in progress to minimize the overhead in processing, data buffering\nand memory round-trips incurred by secure network communications proto-\ncols, such as IPSEC and SSL. While network processors have been designed\nto accelerate the processing of the traditional network protocol stack, \u201Csecu-\nrity protocol engines\u201D have been proposed to accelerate the security protocol\nprocessing, e.g., the IPSEC (Internet Protocol SECurity) portion of the IP\nnetwork protocol processing [56, 57, 58].\n"],"Page":5,"Number":4,"Type":"Figure","CaptionBB":[434,974,772,1002],"Height":1100,"Width":850,"DPI":100,"ImageBB":[439,662,770,956]}