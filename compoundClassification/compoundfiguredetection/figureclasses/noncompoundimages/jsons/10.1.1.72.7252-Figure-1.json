{"Caption":"Figure 1. A first-order decision tree describing a general policy for stacking any two specific blocks.","ImageText":[{"Text":"goal_on(A,B),","TextBB":[361.614,93.999,404.539,100.686],"Rotation":0},{"Text":"move(C,D)","TextBB":[406.397,93.999,440.034,100.686],"Rotation":0},{"Text":"clear(A)","TextBB":[389.478,117.219,414.229,123.906],"Rotation":0},{"Text":"clear(B)","TextBB":[305.886,138.117,330.228,144.804],"Rotation":0},{"Text":"equal(A,C)","TextBB":[257.124,161.337,290.345,168.024],"Rotation":0},{"Text":"equal(B,D)","TextBB":[229.26,182.235,262.481,188.922],"Rotation":0},{"Text":"optimal","TextBB":[217.65,203.133,240.357,209.82],"Rotation":0},{"Text":"above(C,B)","TextBB":[333.75,161.337,368.212,168.024],"Rotation":0},{"Text":"non−optimal","TextBB":[271.056,182.235,309.1,188.922],"Rotation":0},{"Text":"non−optimal","TextBB":[252.48,203.133,290.524,209.82],"Rotation":0},{"Text":"above(C,A)","TextBB":[493.968,138.117,528.839,144.804],"Rotation":0},{"Text":"equal(A,D)","TextBB":[322.207,182.235,355.837,188.922],"Rotation":0},{"Text":"non−optimal","TextBB":[305.886,203.133,343.93,209.82],"Rotation":0},{"Text":"non−optimal","TextBB":[366.355,182.235,404.398,188.922],"Rotation":0},{"Text":"optimal","TextBB":[356.97,203.133,379.677,209.82],"Rotation":0},{"Text":"above(D,B)","TextBB":[449.85,161.337,484.721,168.024],"Rotation":0},{"Text":"non−optimal","TextBB":[424.308,182.235,462.352,188.922],"Rotation":0},{"Text":"optimal","TextBB":[475.392,182.235,498.099,188.922],"Rotation":0},{"Text":"above(C,B)","TextBB":[552.018,161.337,586.48,168.024],"Rotation":0},{"Text":"above(D,A)","TextBB":[524.154,182.235,559.434,188.922],"Rotation":0},{"Text":"non−optimal","TextBB":[505.578,203.133,543.622,209.82],"Rotation":0},{"Text":"non−optimal","TextBB":[572.946,182.235,610.989,188.922],"Rotation":0},{"Text":"optimal","TextBB":[554.34,203.133,577.047,209.82],"Rotation":0}],"Mention":["One direct way of referencing blocks without using\ntheir specific identity, is to build a logical model of\nthe value-function or policy and restricting the gener-\nalization algorithm to refer to objects only indirectly,\nthrough the use of variables. One example of such an\napproach is the RRL-tg algorithm (Driessens et al.,\n2001), which uses a first-order decision tree to approxi-\nmate the value function or the policy.2 Figure 1 shows\nan example of a policy in the shape of a first-order de-\ncision tree for the \u201Con(A,B)\u201D goal that works for any\nnumber of blocks. As well as solving the \u201Con\u201D-problem\nfor any two blocks in the world, the abstraction made\nby such a parameterized policy, also works in worlds\nwith a different number of objects. By focussing only\non the blocks that are featured in the goal or the cur-\nrent action the constructed policy becomes indifferent\nto other objects (or distractions) that might or might\nnot be present. However, to be able to do this, the\nuse of the above(X,Y) predicate was required. While\nRRL-tg will be able to construct an optimal policy\nusing only clear(X) and on(X,Y) predicates, the re-\nsulting tree will not transfer so easily to worlds with\ndifferent numbers of blocks. The success of the knowl-\nedge transfer will often depend on the representations\n","It is possible to apply the same approach as discussed\nbefore to further abstract reinforcement learning prob-\nlems. Where parameterization up to now only used to\nabstract over specific object identities, it could also be\nused to abstract over structural differences in tasks.\nInstead of starting the tree of Figure 1 with the pred-\nicate goal on(A,B), we could have initiated the root\nwith the predicate goal(X). This would make abstrac-\ntion of the exact structure of the goal, so that e.g.\nthe reinforcement learning algorithm could learn both\n\u201DBuild one large stack\u201D and \u201DPut block X on block Y\u201D\nin the same tree. The cost would be similar to that of\nother parameterisation, as still only term logic (no first\nor second-order logics) would be involved to represent\nthe goal.\n","first-order trees make it impossible to make a\nstraightforward swap of the two tests. Depen-\ndencies between tests in first-order trees originate\nfrom the use of variables. Any node can introduce\nnew variables that can be referenced elsewhere in\nthe tree. Removing such a node can change the se-\nmantics of the tests referring to the (also) deleted\nvariables. E.g. the semantics of the tree shown\nin Figure 1 would change substantially if we re-\nmoved the initialization conjunction at the top.\nOne option is to prune the tree completely start-\ning from the deleted test, putting a new two-leaf\ntree with the new test at the root in its place, but\na lot of information would be lost in this way. In-\nstead, we will opt to use a copy of the subtree that\nstarts with the old test as both the left and the\nright subtree of the new node. This will allow the\nre-use of the information stored in the previously\nbuilt subtree, and, if the new test is chosen wisely,\na large portion of the two subtrees will be pruned\nagain at later stages by operators 2 and 4.\n"],"Page":3,"Number":1,"Type":"Figure","CaptionBB":[131,236,691,249],"Height":1100,"Width":850,"DPI":100,"ImageBB":[215,92,613,212]}